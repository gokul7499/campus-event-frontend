{"ast":null,"code":"/**\n * Utility functions for formatting addresses\n *//**\n * Format an address object or string into a readable string\n * @param {Object|string} address - Address object or string\n * @returns {string} Formatted address string\n */export const formatAddress=address=>{if(!address)return'';// If it's already a string, return as is\nif(typeof address==='string'){return address;}// If it's an object, format it\nif(typeof address==='object'){const parts=[address.street,address.city,address.state,address.zipCode,address.country].filter(Boolean);// Remove empty/null/undefined values\nreturn parts.join(', ');}return'';};/**\n * Format address for display with line breaks\n * @param {Object|string} address - Address object or string\n * @returns {Array} Array of address lines\n */export const formatAddressLines=address=>{if(!address)return[];// If it's already a string, return as single line\nif(typeof address==='string'){return[address];}// If it's an object, format it with proper line breaks\nif(typeof address==='object'){const lines=[];if(address.street){lines.push(address.street);}const cityStateZip=[address.city,address.state,address.zipCode].filter(Boolean).join(', ');if(cityStateZip){lines.push(cityStateZip);}if(address.country){lines.push(address.country);}return lines;}return[];};/**\n * Get a short version of the address (typically just city, state)\n * @param {Object|string} address - Address object or string\n * @returns {string} Short address string\n */export const formatShortAddress=address=>{if(!address)return'';// If it's already a string, return first part\nif(typeof address==='string'){return address.split(',')[0]||address;}// If it's an object, return city and state\nif(typeof address==='object'){const parts=[address.city,address.state].filter(Boolean);return parts.join(', ');}return'';};","map":{"version":3,"names":["formatAddress","address","parts","street","city","state","zipCode","country","filter","Boolean","join","formatAddressLines","lines","push","cityStateZip","formatShortAddress","split"],"sources":["C:/Users/Baap/Desktop/u18/frontend/src/utils/addressUtils.js"],"sourcesContent":["/**\n * Utility functions for formatting addresses\n */\n\n/**\n * Format an address object or string into a readable string\n * @param {Object|string} address - Address object or string\n * @returns {string} Formatted address string\n */\nexport const formatAddress = (address) => {\n  if (!address) return '';\n  \n  // If it's already a string, return as is\n  if (typeof address === 'string') {\n    return address;\n  }\n  \n  // If it's an object, format it\n  if (typeof address === 'object') {\n    const parts = [\n      address.street,\n      address.city,\n      address.state,\n      address.zipCode,\n      address.country\n    ].filter(Boolean); // Remove empty/null/undefined values\n    \n    return parts.join(', ');\n  }\n  \n  return '';\n};\n\n/**\n * Format address for display with line breaks\n * @param {Object|string} address - Address object or string\n * @returns {Array} Array of address lines\n */\nexport const formatAddressLines = (address) => {\n  if (!address) return [];\n  \n  // If it's already a string, return as single line\n  if (typeof address === 'string') {\n    return [address];\n  }\n  \n  // If it's an object, format it with proper line breaks\n  if (typeof address === 'object') {\n    const lines = [];\n    \n    if (address.street) {\n      lines.push(address.street);\n    }\n    \n    const cityStateZip = [\n      address.city,\n      address.state,\n      address.zipCode\n    ].filter(Boolean).join(', ');\n    \n    if (cityStateZip) {\n      lines.push(cityStateZip);\n    }\n    \n    if (address.country) {\n      lines.push(address.country);\n    }\n    \n    return lines;\n  }\n  \n  return [];\n};\n\n/**\n * Get a short version of the address (typically just city, state)\n * @param {Object|string} address - Address object or string\n * @returns {string} Short address string\n */\nexport const formatShortAddress = (address) => {\n  if (!address) return '';\n  \n  // If it's already a string, return first part\n  if (typeof address === 'string') {\n    return address.split(',')[0] || address;\n  }\n  \n  // If it's an object, return city and state\n  if (typeof address === 'object') {\n    const parts = [address.city, address.state].filter(Boolean);\n    return parts.join(', ');\n  }\n  \n  return '';\n};\n"],"mappings":"AAAA;AACA;AACA,GAEA;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAA,aAAa,CAAIC,OAAO,EAAK,CACxC,GAAI,CAACA,OAAO,CAAE,MAAO,EAAE,CAEvB;AACA,GAAI,MAAO,CAAAA,OAAO,GAAK,QAAQ,CAAE,CAC/B,MAAO,CAAAA,OAAO,CAChB,CAEA;AACA,GAAI,MAAO,CAAAA,OAAO,GAAK,QAAQ,CAAE,CAC/B,KAAM,CAAAC,KAAK,CAAG,CACZD,OAAO,CAACE,MAAM,CACdF,OAAO,CAACG,IAAI,CACZH,OAAO,CAACI,KAAK,CACbJ,OAAO,CAACK,OAAO,CACfL,OAAO,CAACM,OAAO,CAChB,CAACC,MAAM,CAACC,OAAO,CAAC,CAAE;AAEnB,MAAO,CAAAP,KAAK,CAACQ,IAAI,CAAC,IAAI,CAAC,CACzB,CAEA,MAAO,EAAE,CACX,CAAC,CAED;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAC,kBAAkB,CAAIV,OAAO,EAAK,CAC7C,GAAI,CAACA,OAAO,CAAE,MAAO,EAAE,CAEvB;AACA,GAAI,MAAO,CAAAA,OAAO,GAAK,QAAQ,CAAE,CAC/B,MAAO,CAACA,OAAO,CAAC,CAClB,CAEA;AACA,GAAI,MAAO,CAAAA,OAAO,GAAK,QAAQ,CAAE,CAC/B,KAAM,CAAAW,KAAK,CAAG,EAAE,CAEhB,GAAIX,OAAO,CAACE,MAAM,CAAE,CAClBS,KAAK,CAACC,IAAI,CAACZ,OAAO,CAACE,MAAM,CAAC,CAC5B,CAEA,KAAM,CAAAW,YAAY,CAAG,CACnBb,OAAO,CAACG,IAAI,CACZH,OAAO,CAACI,KAAK,CACbJ,OAAO,CAACK,OAAO,CAChB,CAACE,MAAM,CAACC,OAAO,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,CAE5B,GAAII,YAAY,CAAE,CAChBF,KAAK,CAACC,IAAI,CAACC,YAAY,CAAC,CAC1B,CAEA,GAAIb,OAAO,CAACM,OAAO,CAAE,CACnBK,KAAK,CAACC,IAAI,CAACZ,OAAO,CAACM,OAAO,CAAC,CAC7B,CAEA,MAAO,CAAAK,KAAK,CACd,CAEA,MAAO,EAAE,CACX,CAAC,CAED;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAG,kBAAkB,CAAId,OAAO,EAAK,CAC7C,GAAI,CAACA,OAAO,CAAE,MAAO,EAAE,CAEvB;AACA,GAAI,MAAO,CAAAA,OAAO,GAAK,QAAQ,CAAE,CAC/B,MAAO,CAAAA,OAAO,CAACe,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAIf,OAAO,CACzC,CAEA;AACA,GAAI,MAAO,CAAAA,OAAO,GAAK,QAAQ,CAAE,CAC/B,KAAM,CAAAC,KAAK,CAAG,CAACD,OAAO,CAACG,IAAI,CAAEH,OAAO,CAACI,KAAK,CAAC,CAACG,MAAM,CAACC,OAAO,CAAC,CAC3D,MAAO,CAAAP,KAAK,CAACQ,IAAI,CAAC,IAAI,CAAC,CACzB,CAEA,MAAO,EAAE,CACX,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}