{"ast":null,"code":"import _objectSpread from\"C:/Users/Baap/Desktop/campus-event-management/campus-event-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{createContext,useContext,useReducer,useEffect,useCallback}from'react';import{toast}from'react-toastify';import axios from'../utils/axios';import{useSocket}from'./SocketContext';import{useAuth}from'./AuthContext';// Initial state\nimport{jsx as _jsx}from\"react/jsx-runtime\";const initialState={notifications:[],unreadCount:0,loading:false,error:null};// Action types\nconst NOTIFICATION_ACTIONS={FETCH_START:'FETCH_START',FETCH_SUCCESS:'FETCH_SUCCESS',FETCH_FAILURE:'FETCH_FAILURE',ADD_NOTIFICATION:'ADD_NOTIFICATION',MARK_AS_READ:'MARK_AS_READ',MARK_ALL_AS_READ:'MARK_ALL_AS_READ',DELETE_NOTIFICATION:'DELETE_NOTIFICATION',UPDATE_UNREAD_COUNT:'UPDATE_UNREAD_COUNT',CLEAR_ERROR:'CLEAR_ERROR'};// Reducer\nconst notificationReducer=(state,action)=>{switch(action.type){case NOTIFICATION_ACTIONS.FETCH_START:return _objectSpread(_objectSpread({},state),{},{loading:true,error:null});case NOTIFICATION_ACTIONS.FETCH_SUCCESS:return _objectSpread(_objectSpread({},state),{},{notifications:action.payload.notifications,unreadCount:action.payload.unreadCount,loading:false,error:null});case NOTIFICATION_ACTIONS.FETCH_FAILURE:return _objectSpread(_objectSpread({},state),{},{loading:false,error:action.payload});case NOTIFICATION_ACTIONS.ADD_NOTIFICATION:return _objectSpread(_objectSpread({},state),{},{notifications:[action.payload,...state.notifications],unreadCount:state.unreadCount+1});case NOTIFICATION_ACTIONS.MARK_AS_READ:return _objectSpread(_objectSpread({},state),{},{notifications:state.notifications.map(notification=>notification._id===action.payload?_objectSpread(_objectSpread({},notification),{},{isRead:true,readAt:new Date()}):notification),unreadCount:Math.max(0,state.unreadCount-1)});case NOTIFICATION_ACTIONS.MARK_ALL_AS_READ:return _objectSpread(_objectSpread({},state),{},{notifications:state.notifications.map(notification=>_objectSpread(_objectSpread({},notification),{},{isRead:true,readAt:new Date()})),unreadCount:0});case NOTIFICATION_ACTIONS.DELETE_NOTIFICATION:const deletedNotification=state.notifications.find(n=>n._id===action.payload);return _objectSpread(_objectSpread({},state),{},{notifications:state.notifications.filter(n=>n._id!==action.payload),unreadCount:deletedNotification&&!deletedNotification.isRead?Math.max(0,state.unreadCount-1):state.unreadCount});case NOTIFICATION_ACTIONS.UPDATE_UNREAD_COUNT:return _objectSpread(_objectSpread({},state),{},{unreadCount:action.payload});case NOTIFICATION_ACTIONS.CLEAR_ERROR:return _objectSpread(_objectSpread({},state),{},{error:null});default:return state;}};// Create context\nconst NotificationContext=/*#__PURE__*/createContext();// Notification provider component\nexport const NotificationProvider=_ref=>{let{children}=_ref;const[state,dispatch]=useReducer(notificationReducer,initialState);const{socket,onNotification}=useSocket();const{user}=useAuth();// Fetch notifications\nconst fetchNotifications=useCallback(async function(){let page=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;let limit=arguments.length>1&&arguments[1]!==undefined?arguments[1]:20;if(!user)return;dispatch({type:NOTIFICATION_ACTIONS.FETCH_START});try{const[notificationsResponse,unreadCountResponse]=await Promise.all([axios.get(\"/api/notifications?page=\".concat(page,\"&limit=\").concat(limit)),axios.get('/api/notifications?isRead=false&limit=1')]);dispatch({type:NOTIFICATION_ACTIONS.FETCH_SUCCESS,payload:{notifications:notificationsResponse.data.data,unreadCount:unreadCountResponse.data.pagination.totalItems}});}catch(error){var _error$response,_error$response$data;dispatch({type:NOTIFICATION_ACTIONS.FETCH_FAILURE,payload:((_error$response=error.response)===null||_error$response===void 0?void 0:(_error$response$data=_error$response.data)===null||_error$response$data===void 0?void 0:_error$response$data.message)||'Failed to fetch notifications'});}},[user]);// Mark notification as read\nconst markAsRead=async notificationId=>{try{await axios.put(\"/api/notifications/\".concat(notificationId,\"/read\"));dispatch({type:NOTIFICATION_ACTIONS.MARK_AS_READ,payload:notificationId});}catch(error){console.error('Failed to mark notification as read:',error);}};// Mark all notifications as read\nconst markAllAsRead=async()=>{try{await axios.put('/api/notifications/read-all');dispatch({type:NOTIFICATION_ACTIONS.MARK_ALL_AS_READ});}catch(error){console.error('Failed to mark all notifications as read:',error);}};// Delete notification\nconst deleteNotification=async notificationId=>{try{await axios.delete(\"/api/notifications/\".concat(notificationId));dispatch({type:NOTIFICATION_ACTIONS.DELETE_NOTIFICATION,payload:notificationId});}catch(error){console.error('Failed to delete notification:',error);}};// Show toast notification\nconst showToast=function(message){let type=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'info';let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const defaultOptions=_objectSpread({position:'top-right',autoClose:5000,hideProgressBar:false,closeOnClick:true,pauseOnHover:true,draggable:true},options);switch(type){case'success':toast.success(message,defaultOptions);break;case'error':toast.error(message,defaultOptions);break;case'warning':toast.warning(message,defaultOptions);break;case'info':default:toast.info(message,defaultOptions);break;}};// Send notification\nconst sendNotification=async notificationData=>{try{const response=await axios.post('/api/notifications/send',notificationData);return{success:true,data:response.data};}catch(error){var _error$response2,_error$response2$data;const errorMessage=((_error$response2=error.response)===null||_error$response2===void 0?void 0:(_error$response2$data=_error$response2.data)===null||_error$response2$data===void 0?void 0:_error$response2$data.message)||'Failed to send notification';return{success:false,error:errorMessage};}};// Send bulk notification\nconst sendBulkNotification=async notificationData=>{try{const response=await axios.post('/api/notifications/send-bulk',notificationData);return{success:true,data:response.data};}catch(error){var _error$response3,_error$response3$data;const errorMessage=((_error$response3=error.response)===null||_error$response3===void 0?void 0:(_error$response3$data=_error$response3.data)===null||_error$response3$data===void 0?void 0:_error$response3$data.message)||'Failed to send bulk notification';return{success:false,error:errorMessage};}};// Clear error\nconst clearError=()=>{dispatch({type:NOTIFICATION_ACTIONS.CLEAR_ERROR});};// Listen for real-time notifications\nuseEffect(()=>{if(socket&&user){const cleanup=onNotification(notification=>{// Add to state\ndispatch({type:NOTIFICATION_ACTIONS.ADD_NOTIFICATION,payload:notification});// Show toast notification\nshowToast(notification.message,'info',{onClick:()=>markAsRead(notification.id)});});return cleanup;}},[socket,user,onNotification]);// Fetch notifications when user logs in\nuseEffect(()=>{if(user){fetchNotifications();}},[user,fetchNotifications]);const value=_objectSpread(_objectSpread({},state),{},{fetchNotifications,markAsRead,markAllAsRead,deleteNotification,showToast,sendNotification,sendBulkNotification,clearError});return/*#__PURE__*/_jsx(NotificationContext.Provider,{value:value,children:children});};// Custom hook to use notification context\nexport const useNotification=()=>{const context=useContext(NotificationContext);if(!context){throw new Error('useNotification must be used within a NotificationProvider');}return context;};export default NotificationContext;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}